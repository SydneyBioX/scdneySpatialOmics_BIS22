---
title: "Dirty Analysis"
output: html_document
date: "2022-11-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```


```{r}
library(imcdatasets)
library(scater)
library(simpleSeg)
library(FuseSOM)
library(lisaClust)
library(ClassifyR)
library(spicyR)
```

# Global paramaters

It is convenient to set the number of cores for running code in parallel. Please choose a number that is appropriate for your resources. Some functions will just need the number of cores, `nCores`, some will need a `BPPARAM` object from the `BiocParallel` package.

```{r}
nCores <- 4
BPPARAM <- simpleSeg:::generateBPParam(nCores)
theme_set(theme_classic())
```


# Context

In the following we will reanalyse some Imaging Mass Cytometry (IMC) data [(Damond et al, 2019)](https://www.cell.com/cell-metabolism/fulltext/S1550-4131(18)30691-0) profiling the spatial landscape of pancreatic islets in subjects with long-duration diabetes, recent onset diabetes and controls. The key conclusion of this manuscript (amongst others) is that spatial organisation of cells is indicative of diabetes progress. We will use our spicy workflow to make a similar conclusion.

The R code for this analysis is available on github XXX


# Download data

A subset of the IMC data published in [(Damond et al, 2019)](https://www.cell.com/cell-metabolism/fulltext/S1550-4131(18)30691-0) is available in the 
`imcdatasets` package on Bioconductor. This data can be loaded into a `SpatialExperiment` object as follows.

```{r}
cells <- imcdatasets::Damond_2019_Pancreas(data_type = "spe")
```

### QUESTIONS how many cells are in this data? How many markers? How many images? Are there any interesting patient characteristics.


## Subset data

To make things faster and less computationally demanding, lets subset the data down to 60 pancreatic islets from an equal number of non-diabetic, recent onset and long-duration diabetics.


```{r}

set.seed(51773)

useImages <- c(sample(cells$image_name[cells$patient_stage=="Non-diabetic"], 20),
               sample(cells$image_name[cells$patient_stage=="Onset"], 20),
               sample(cells$image_name[cells$patient_stage=="Long-duration"], 20))

cells <- cells[, cells$image_name %in% useImages]

```


## Dimension reduction

As our data is stored in a `SpatialExperiment`, as we did previously we can use `scater` to perform and visualise our data in a lower dimensional embedding to look for image or cluster differences.

```{r}
set.seed(51773)
# Perform dimension reduction using UMP.
cells <- scater::runUMAP(cells, exprs_values = "counts", name = "UMAP_raw")

# UMAP by imageID.
scater::plotReducedDim(cells, dimred="UMAP_raw", colour_by = "image_name")

```


### QUESTIONS is this umap highlighting any "interesting" structure in the data? What does it mean that cells from different images cluster together? Can you modify this to look for relationships to disease stage? One of the columns contains the cell types defined by Damond et al, are these cell types separated on the UMAP?


# Normalize data

We should check to see if the marker intensities of each cell require some form of transformation or normalisation. Here we extract the intensities from the `counts` assay. Looking at SMA which should be expressed in the majority of the stromal cells, the intensities are clearly very skewed and the peaks of the lower intensities don't overlap.


```{r, fig.width=5, fig.height=5}
# Extract marker data and bind with information about images
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))
# Plots densities of PanKRT for each image.
ggplot(df, aes(x = sqrt(SMA), colour = image_name)) + 
  geom_density() + 
  theme(legend.position = "none")
```


We can transform and normalise our data using the `normalizeCells` function. Here we have taken the intensities from the `counts` assay, performed an inverse hyperbolic sine transform, then for each image trimmed the 99 quantile, scaled the means to be equal and then removed the first principal component. This modified data is then store in the `norm` assay by default. We can see that this normalised data appears to align more, not perfect, but likely sufficient for clustering.

### QUESTION Do different normalisations looks different? What about different markers?


```{r, fig.width=5, fig.height=5}
# Transform and normalise the marker expression of each cell type.
# Use a square root transform, then trimmed the 99 quantile 
cells <- normalizeCells(cells, 
                        transformation = "asinh", 
                        method = c("trim99", "mean", "PC1"), 
                        assayIn = "counts", 
                        cores = nCores,
                        imageID = "image_name"
                        )
# Extract normalised marker information.
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))
# Plots densities of normalised PanKRT for each image.
ggplot(df, aes(x = SMA, colour = image_name)) + 
  geom_density() + 
  theme(legend.position = "none")
```

# FuseSOM: Cluster cells into cell types

We'd like to annotated cells as different cell types.

Our FuseSOM R package on [Bioconductor](http://www.bioconductor.org/packages/release/bioc/html/FuseSOM.html) provides a pipeline for the clustering cells in highly multiplexed in situ imaging cytometry assays. This pipeline uses the Self Organizing Map architecture coupled with Multiview hierarchical clustering and provides functions for the estimation of the number of clusters.


## Marker selection

First, let's select the markers that we'd like to use to cluster the cells. Clustering partitions the data by the largest sources of variation. If there are lots of markers for a specific cell type, this will cluster very well.  

```{r}

# Order the markers sensibly

useMarkers <- c(
#"INS",	#Insulin	β	141Pr
#"PIN",	#Proinsulin	β	154Sm
"NKX6_1", #	Homeobox protein Nkx-6.1	β	169Tm
"IAPP", #	Amylin	β	167Er
"GCG", #	Glucagon	α	156Gd
"PCSK2",	#Proprotein convertase 2	α	144Nd
"SST",	#Somatostatin	δ	159Tb
"PPY",	#Pancreatic polypeptide	γ	153Eu
"PDX1",	#Pancreatic and duodenal homeobox 1	β, δ, ductal	158Gd
"SYP",	#Synaptophysin	Endocrine	160Gd
"CD99",	#CD99	Endocrine	145Nd
"SLC2A1",	#Glucose transporter 1	Endocrine	148Nd
"PTPRN",	#Receptor-type tyrosine-protein phosphatase-like N	Endocrine	174Yb
"AMY2A",	#Pancreatic amylase	Acinar	150Nd
"KRT19",	#Cytokeratin 19	Ductal	161Dy
"CD44",	#CD44	Exocrine	143Nd
"CD45",	#CD45	Immune	162Dy
"CD45RA",	#CD45RA	Immune	164Dy
"CD3e",	#CD3ɛ	T	152Sm
"CD4",	#CD4	Helper T	171Yb
"CD8a",	#CD8a	Cytotoxic T	165Ho
"CD20",	#CD20	B	149Sm
"CD68",	#CD68	Monocytes, macrophages	146Nd
"MPO",	#Myeloperoxidase	Neutrophils	147Sm
"FOXP3",	#Forkhead box P3	Regulatory T	163Dy
"CD38",	#CD38	Immune	142Nd
"CDH1",	#E-/P-cadherin	Epithelial	173Yb
"CD31",	#CD31	Endothelial	172Yb
"SMA",	#Smooth muscle actin	Stromal	115In
"Ki67",	#Ki-67	Proliferating	168Er
"p_HH3",	#Phospho-histone H3	Proliferating	170Er
"p_Rb",	#Phospho-retinoblastoma	Cycling	175Yb
"cPARP_cCASP3",	#Cleaved caspase 3 + cleaved poly (ADP-ribose) polymerase	Apoptotic	176Yb
"CA9")	#Carbonic anhydrase IX	Hypoxic	166Er


```



## Perform clustering

Here we cluster using the `runFuseSOM` function. We have chosen to specify the same subset of markers used in the original manuscript for gating cell types. We have also specified the number of clusters to identify to be `numClusters = 19`. In addtion to this, while FuseSOM can automatically estimate a grid size for the self organising map, we have set the grid size to be `size = 10` to specify a 10 by 10 grid that should allow for smaller cell subsets to be identified.

```{r}
# Set seed.
set.seed(51773)
# Generate SOM and cluster cells into 20 groups.
cells <- runFuseSOM(cells, 
                    markers = useMarkers, 
                    assay = 'norm', 
                    numClusters = 13)
```
## Check how many clusters should be used.

We can check to see how reasonable our choice of 14 clusters is using the `estimateNumCluster` and the `optiPlot` functions. Here we examine the Gap method, others such as Silhouette and Within Cluster Distance are also available.


```{r}
cells <- estimateNumCluster(cells, kSeq = 2:30)
optiPlot(cells, method = "gap")
cells@metadata$clusterEstimation$Discriminant
```
## Attempt to interpret the phenotype of each cluster

We can begin the process of understanding what each of these cell clusters are by using the `plotGroupedHeatmap` function from `scater`. At the least, here we can see we capture a few different populations of islet cells and a few immune cell populates (including CD4+ Tcells and CD8+ Tcells).



```{r, fig.height = 7}
scater::plotGroupedHeatmap(cells,
  features = useMarkers,
  group = "clusters",
  exprs_values = "exprs",
  center = TRUE,
  scale = TRUE,
  zlim = c(-3, 3),
  cluster_rows = FALSE
)
```


Damond et al define their cell types using a step wise clustering procedure with manual merge of clusters. We can compare our clustering to theirs.

```{r fig.width=8}
regionMap(cells,cellType = "clusters", region = "cell_type") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

## Check cluster frequencies

We find it always useful to check the number of cells in each cluster. Here we can see that cluster 3 is contains lots of (most likely tumour) cells and cluster 7 contains very few cells.

```{r}
# Check cluster frequencies.
colData(cells)$clusters |>
  table() |>
  sort()
```

## Visualise cell types in an image

Look at the distribution of cells types in an image


```{r}
# Extract cell information and filter to specific image.
df <- cbind(colData(cells), spatialCoords(cells)) |>
as.data.frame() |>
dplyr::filter(image_name == "E02")
# Colour cells by their region.
ggplot(df, aes(x = cell_x, y = cell_y, colour = clusters)) +
  geom_point()
```

### QUESTIONS Does changing the normalisation affect the clustering? Does changing the number of clusters? 



# Test For association between the proportion of each cell type and progression status

We recommend using a package such as `diffcyt` for testing for changes in abundance of cell types. However, the `colTest` function allows us to quickly test for associations between the proportions of the cell types and disease status using either Wilcoxon rank sum tests or t-tests. Here we see a couple of p-values less than 0.05.

```{r}
# Select cells which belong to Non-diabetic individuals and those with recent onset diabetes.
cellsToUse <- cells$patient_stage%in%c("Non-diabetic", "Onset")
# Perform simple t tests on the columns of the proportion matrix.
testProp <- colTest(cells[, cellsToUse], 
                    condition = "patient_stage", 
                    feature = "clusters",
                    imageID = "image_name")
testProp
```




# spicyR: test spatial relationships

Our spicyR package (https://www.bioconductor.org/packages/devel/bioc/html/spicyR.html)[https://www.bioconductor.org/packages/devel/bioc/html/spicyR.html] provides a series of functions to aid in the analysis of both immunofluorescence and mass cytometry imaging data as well as other assays that can deeply phenotype individual cells and their spatial location. Here we use the `spicy` function to test for changes in the spatial relationships between pairwise combinations of cells. We quantify spatial relationships using a combination of three radii `Rs = c(20, 50, 100)` and mildly account for some global tissue structure using `sigma = 50`.

```{r}
# Select cells which belong to Non-diabetic individuals and those with recent onset diabetes.
cellsToUse <- cells$patient_stage%in%c("Non-diabetic", "Onset")

# Test for changes in pairwise spatial relationships between cell types.
spicyTest <- spicy(cells[, cellsToUse], 
                   condition = "patient_stage", 
                   cellType = "clusters",
                   imageID = "image_name",
                   spatialCoords = c("cell_x", "cell_y"),
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   BPPARAM = BPPARAM)
topPairs(spicyTest, n = 10)
```

We can visualise these tests using `signifPlot` where we observe that cell type pairs appear to become less attractive (or avoid more) SOMETHING ABOUT INTERPRATION.

```{r}
# Visualise which relationships are changing the most.
signifPlot(spicyTest,
           breaks = c(-1.5, 3, 0.5),
           cutoff = 0.0001)
```

### QUESTION: Do the results/interpretation change if use Rs = 20 or Rs = 200



# lisaClust: Find cellular neighbourhoods

Our lisaClust package (https://www.bioconductor.org/packages/release/bioc/html/lisaClust.html)[https://www.bioconductor.org/packages/release/bioc/html/lisaClust.html] provides a series of functions to identify and visualise regions of tissue where spatial associations between cell-types is similar. This package can be used to provide a high-level summary of cell-type colocalisation in multiplexed imaging data that has been segmented at a single-cell resolution. Here we use the `lisaClust` function to clusters cells into 5 regions with distinct spatial ordering. 




```{r}
set.seed(51773)
# Cluster cells into spatial regions with similar composition.
cells <- lisaClust(cells, 
                   k = 5, 
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   spatialCoords = c("cell_x", "cell_y"), 
                   cellType = "clusters", 
                   imageID = "image_name",
                   BPPARAM = BPPARAM)
```

## Region - cell type enrichment heatmap

We can try to interpret which spatial orderings the regions are quantifying using the `regionMap` function. This plots the frequency of each cell type in a region relative to what you would expect by chance.

```{r, fig.height=5, fig.width=5}
# Visualise the enrichment of each cell type in each region
regionMap(cells, cellType = "clusters", limit = c(0.2, 5))
```

## Visualise regions

By default, these identified regions are stored in the `regions` column in the `colData` of our object. We can quickly examine the spatial arrangement of these regions using `ggplot`.


```{r}
# Extract cell information and filter to specific image.
df <- colData(cells) |>
as.data.frame() |>
filter(imageID == "Point2206_pt1116_31620")
# Colour cells by their region.
ggplot(df, aes(x = m.cx, y = m.cy, colour = region)) +
  geom_point()
```


While much slower, we have also implemented a function for overlaying the region information as a hatching pattern so that the information can be viewed simultaneously with the cell type calls.

```{r eval = FALSE}
# Use hatching to visualise regions and cell types.
hatchingPlot(cells,
             useImages = "Point2206_pt1116_31620",
             cellType = "clusters",
             spatialCoords = c("m.cx", "m.cy")
            )
```


## Test for changes in cell type proportions

```{r}
regionProp <- getProp(cells, feature = "region", imageID = "image_name")


stage <- cells |>
  colData() |>
  as.data.frame() |>
  dplyr::select("image_name", "patient_stage") |>
  unique() |>
  mutate(patient_stage = factor(patient_stage, levels = c("Non-diabetic",
                                                          "Onset",
                                                          "Long-duration")))


df <- regionProp |>
  mutate(image_name = rownames(regionProp)) |>
  dplyr::right_join(stage, by = "image_name") |>
  tidyr::pivot_longer(cols = starts_with("region"),
                      names_to = "region",
                      values_to = "proportion")

ggplot(df, aes(x = region, y = proportion, colour = patient_stage)) + geom_boxplot()

```
## Test for changes in proportions of the regions

SOMETHING ABOUT Islets with and without beta cells.

```{r}
# Select cells which belong to Non-diabetic individuals and those with recent onset diabetes.
cellsToUse <- cells$patient_stage%in%c("Non-diabetic", "Onset")
# Perform simple t tests on the columns of the proportion matrix.
testRegions<- colTest(cells[, cellsToUse], 
                    condition = "patient_stage", 
                    feature = "region",
                    imageID = "image_name")
testRegions

```

### QUESTION do the conclusions change using more or less regions?

# ClassifyR: Classification

Our ClassifyR package, [https://github.com/SydneyBioX/ClassifyR](https://github.com/SydneyBioX/ClassifyR), formalises a convenient framework for evaluating classification in R. We provide functionality to easily include four key modelling stages; Data transformation, feature selection, classifier training and prediction; into a cross-validation loop. Here we use the `crossValidate` function to perform 20 repeats of 5-fold cross-validation to evaluate the performance of an randomForest applied to three quantification of our IMC data; cell type proportions, average pairwise distances between cell-types and region proportions.


```{r message=FALSE}
# Create list to store data.frames
data <- list()
# Add proportions of each cell type in each image
data[["props"]] <- getProp(cells, feature = "clusters", imageID = "image_name")
# Add pairwise associations
data[["dist"]] <- getPairwise(cells, 
                              spatialCoords = c("cell_x", "cell_y"),
                              imageID = "image_name",
                              cellType = "clusters",
                              Rs = c(20, 50, 100),
                              sigma = 50,
                              BPPARAM = BPPARAM)

data[["dist"]] <- as.data.frame(data[["dist"]])

# Add proportions of each region in each image
# to the list of dataframes.
data[["regions"]] <- getProp(cells, feature = "region", imageID = "image_name")

# Get outcome data
df <- colData(cells)[, c("image_name", "patient_stage")]
df <- unique(df)
rownames(df) <- df$image_name

outcome <- df$patient_stage
names(outcome) <- df$image_name

# Only use onset vs non-diabetic
outcome <- outcome[outcome %in% c("Long-duration", "Onset")]
outcome <- factor(outcome)

measurements <- lapply(data, function(x)x[names(outcome), ])

# Set seed
set.seed(51773)
# Perform cross-validation of an elastic net model
# with 100 repeats of 5-fold cross-validation.
cv <- crossValidate(measurements = measurements, 
                    outcome = outcome,
                    classifier = "randomForest",
                    nFolds = 5,
                    nRepeats = 20,
                    nCores = nCores
                    )
```





## Visualise cross-validated prediction performance

Here we use the `performancePlot` function to assess the AUC from each repeat of the 5-fold cross-validation. We see that the lisaClust regions appear to capture information which is predictive of diabetes progression status of the patients.

```{r}
# Calculate AUC for each cross-validation repeat and plot.
performancePlot(cv,
                performanceName = "AUC",
                characteristicsList = list(x = "Assay Name"))
```



### QUESTIONS Different classifiers? Check balanced accuracy.