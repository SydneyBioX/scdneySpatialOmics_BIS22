---
title: "Dirty Analysis"
output: html_document
date: "2022-11-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```


```{r}
library(imcdatasets)
library(scater)
library(simpleSeg)
library(FuseSOM)
library(lisaClust)
library(ClassifyR)
library(spicyR)
```

# Global paramaters

It is convenient to set the number of cores for running code in parallel. Please choose a number that is appropriate for your resources. Some functions will just need the number of cores, `nCores`, some will need a `BPPARAM` object from the `BiocParallel` package.

```{r}
nCores <- 20
BPPARAM <- simpleSeg:::generateBPParam(nCores)
theme_set(theme_classic())
```


# Context

In the following we will reanalyse some Imaging Mass Cytometry (IMC) data [(Damond et al, 2019)](https://www.cell.com/cell-metabolism/fulltext/S1550-4131(18)30691-0) profiling the spatial landscape of pancreatic islets in subjects with long-duration diabetes, recent onset diabetes and controls. The key conclusion of this manuscript (amongst others) is that spatial organisation of cells is indicative of diabetes progress. We will use our spicy workflow to make a similar conclusion.

The R code for this analysis is available on github XXX [https://github.com/SydneyBioX/spicyWorkflow](https://github.com/SydneyBioX/spicyWorkflow). 


# Download data

A subset of the IMC data published in [(Damond et al, 2019)](https://www.cell.com/cell-metabolism/fulltext/S1550-4131(18)30691-0) is available in the 
`imcdatasets` package on Bioconductor. This data can be loaded into a `SpatialExperiment` object as follows.

```{r}
cells <- imcdatasets::Damond_2019_Pancreas(data_type = "spe")
```

### QUESTIONS how many cells are in this data? How many markers? How many images? Are there any interesting patient characteristics.


## Subset data

To make things faster and less computationally demanding, lets subset the data down to 60 pancreatic islets from an equal number of non-diabetic, recent onset and long-duration diabetics.


```{r}

set.seed(51773)

useImages <- c(sample(cells$image_name[cells$patient_stage=="Non-diabetic"], 20),
               sample(cells$image_name[cells$patient_stage=="Onset"], 20),
               sample(cells$image_name[cells$patient_stage=="Long-duration"], 20))

cells <- cells[, cells$image_name %in% useImages]

```


## Dimension reduction

As our data is stored in a `SpatialExperiment`, as we did previously we can use `scater` to perform and visualise our data in a lower dimensional embedding to look for image or cluster differences.

```{r}
set.seed(51773)
# Perform dimension reduction using UMP.
cells <- scater::runUMAP(cells, exprs_values = "counts", name = "UMAP_raw")

# UMAP by imageID.
scater::plotReducedDim(cells, dimred="UMAP_raw", colour_by = "image_name")

```


### QUESTIONS is this umap highlighting any "interesting" structure in the data? What does it mean that cells from different images cluster together? Can you modify this to look for relationships to disease stage? One of the columns contains the cell types defined by Damond et al, are these cell types separated on the UMAP?


# Normalize data

We should check to see if the marker intensities of each cell require some form of transformation or normalisation. Here we extract the intensities from the `counts` assay. Looking at PanKRT which should be expressed in the majority of the tumour cells, the intensities are clearly very skewed.


```{r, fig.width=5, fig.height=5}
# Extract marker data and bind with information about images
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "counts"))))
# Plots densities of PanKRT for each image.
ggplot(df, aes(x = CD68, colour = image_name)) + 
  geom_density() + 
  theme(legend.position = "none")
```


We can transform and normalise our data using the `normalizeCells` function. Here we have taken the intensities from the `counts` assay, performed a square root transform, then for each image trimmed the 99 quantile and min-max scaled to 0-1. This modified data is then store in the `norm` assay by default. We can see that this normalised data appears more bimodal, not perfect, but likely sufficient for clustering.


```{r, fig.width=5, fig.height=5}
# Transform and normalise the marker expression of each cell type.
# Use a square root transform, then trimmed the 99 quantile 
cells <- normalizeCells(cells, 
                        transformation = "asinh", 
                        method = c("trim99", "mean", "PC1"), 
                        assayIn = "counts", 
                        cores = nCores,
                        imageID = "image_name"
                        )
# Extract normalised marker information.
df <- as.data.frame(cbind(colData(cells), t(assay(cells, "norm"))))
# Plots densities of normalised PanKRT for each image.
ggplot(df, aes(x = PDX1, colour = image_name)) + 
  geom_density() + 
  theme(legend.position = "none")
```


```{r}

# Order the markers sensibly

useMarkers <- c("INS",	#Insulin	β	141Pr
"PIN",	#Proinsulin	β	154Sm
"NKX6_1", #	Homeobox protein Nkx-6.1	β	169Tm
"IAPP", #	Amylin	β	167Er
"GCG", #	Glucagon	α	156Gd
"PCSK2",	#Proprotein convertase 2	α	144Nd
"SST",	#Somatostatin	δ	159Tb
"PPY",	#Pancreatic polypeptide	γ	153Eu
"PDX1",	#Pancreatic and duodenal homeobox 1	β, δ, ductal	158Gd
"SYP",	#Synaptophysin	Endocrine	160Gd
"CD99",	#CD99	Endocrine	145Nd
"SLC2A1",	#Glucose transporter 1	Endocrine	148Nd
"PTPRN",	#Receptor-type tyrosine-protein phosphatase-like N	Endocrine	174Yb
"AMY2A",	#Pancreatic amylase	Acinar	150Nd
"KRT19",	#Cytokeratin 19	Ductal	161Dy
"CD44",	#CD44	Exocrine	143Nd
"CD45",	#CD45	Immune	162Dy
"CD45RA",	#CD45RA	Immune	164Dy
"CD3e",	#CD3ɛ	T	152Sm
"CD4",	#CD4	Helper T	171Yb
"CD8a",	#CD8a	Cytotoxic T	165Ho
"CD20",	#CD20	B	149Sm
"CD68",	#CD68	Monocytes, macrophages	146Nd
"MPO",	#Myeloperoxidase	Neutrophils	147Sm
"FOXP3",	#Forkhead box P3	Regulatory T	163Dy
"CD38",	#CD38	Immune	142Nd
"CDH1",	#E-/P-cadherin	Epithelial	173Yb
"CD31",	#CD31	Endothelial	172Yb
"SMA",	#Smooth muscle actin	Stromal	115In
"Ki67",	#Ki-67	Proliferating	168Er
"p_HH3",	#Phospho-histone H3	Proliferating	170Er
"p_Rb",	#Phospho-retinoblastoma	Cycling	175Yb
"cPARP_cCASP3",	#Cleaved caspase 3 + cleaved poly (ADP-ribose) polymerase	Apoptotic	176Yb
"CA9")	#Carbonic anhydrase IX	Hypoxic	166Er


```



## Perform the clustering
```{r}
# Set seed.
set.seed(51773)
# Generate SOM and cluster cells into 20 groups.
cells <- runFuseSOM(cells, 
                    markers = useMarkers, 
                    assay = 'norm', 
                    numClusters = 20)
```

```{r}
cells <- estimateNumCluster(cells, kSeq = 2:30)
optiPlot(cells, method = "silhouette")
cells@metadata$clusterEstimation$Discriminant
```



```{r, fig.height = 7}
scater::plotGroupedHeatmap(cells,
  features = useMarkers,
  group = "clusters",
  exprs_values = "exprs",
  center = TRUE,
  scale = TRUE,
  zlim = c(-3, 3),
  cluster_rows = FALSE
)
```

```{r}
regionMap(cells,cellType = "clusters", region = "patient_stage")
```

## Check cluster frequencies

We find it always useful to check the number of cells in each cluster. Here we can see that cluster 3 is contains lots of (most likely tumour) cells and cluster 7 contains very few cells.

```{r}
# Check cluster frequencies.
colData(cells)$clusters |>
  table() |>
  sort()
```

```{r}
# Extract cell information and filter to specific image.
df <- cbind(colData(cells), spatialCoords(cells)) |>
as.data.frame() |>
dplyr::filter(image_name == "E02")
# Colour cells by their region.
ggplot(df, aes(x = cell_x, y = cell_y, colour = clusters)) +
  geom_point()
```




```{r}
set.seed(51773)
# Cluster cells into spatial regions with similar composition.
cells <- lisaClust(cells, 
                   k = 5, 
                   Rs = c(20, 50, 100),
                   sigma = 50,
                   spatialCoords = c("cell_x", "cell_y"), 
                   cellType = "clusters", 
                   imageID = "image_name",
                   BPPARAM = BPPARAM)
```

## Region - cell type enrichment heatmap

We can try to interpret which spatial orderings the regions are quantifying using the `regionMap` function. This plots the frequency of each cell type in a region relative to what you would expect by chance.

```{r, fig.height=5, fig.width=5}
# Visualise the enrichment of each cell type in each region
regionMap(cells, cellType = "clusters", limit = c(0.2, 5))
```


# ClassifyR: Classification

Our ClassifyR package, [https://github.com/SydneyBioX/ClassifyR](https://github.com/SydneyBioX/ClassifyR), formalises a convenient framework for evaluating classification in R. We provide functionality to easily include four key modelling stages; Data transformation, feature selection, classifier training and prediction; into a cross-validation loop. Here we use the `crossValidate` function to perform 100 repeats of 5-fold cross-validation to evaluate the performance of an elastic net model applied to three quantification of our MIBI-TOF data; cell type proportions, average mean of each cell type and region proportions.





```{r message=FALSE}
# Create list to store data.frames
data <- list()
# Add proportions of each cell type in each image
data[["props"]] <- getProp(cells, feature = "clusters", imageID = "image_name")
# Add pairwise associations
data[["dist"]] <- getPairwise(cells, 
                              spatialCoords = c("cell_x", "cell_y"),
                              imageID = "image_name",
                              cellType = "clusters",
                              Rs = c(20, 50, 100),
                              sigma = 50,
                              BPPARAM = BPPARAM)
data[["dist"]] <- as.data.frame(data[["dist"]])
# Add proportions of each region in each image
# to the list of dataframes.
data[["regions"]] <- getProp(cells, feature = "region", imageID = "image_name")

df <- colData(cells)[, c("image_name", "patient_stage")]
df <- unique(df)
rownames(df) <- df$image_name

outcome <- df$patient_stage
names(outcome) <- df$image_name


# Only use onset vs non-diabetic
outcome <- outcome[outcome %in% c("Long-duration", "Onset")]
outcome <- factor(outcome)

measurements <- lapply(data, function(x)x[names(outcome), ])

# Set seed
set.seed(51773)
# Perform cross-validation of an elastic net model
# with 100 repeats of 5-fold cross-validation.
cv <- crossValidate(measurements = measurements, 
                    outcome = outcome,
                    classifier = "randomForest",
                    nFolds = 5,
                    nRepeats = 20,
                    nCores = nCores
                    )
```





## Visualise cross-validated prediction performance

Here we use the `performancePlot` function to assess the AUC from each repeat of the 5-fold cross-validation. We see that the lisaClust regions appear to capture information which is predictive of progression status of the patients.

```{r}
# Calculate AUC for each cross-validation repeat and plot.
performancePlot(cv,
                performanceName = "AUC",
                characteristicsList = list(x = "Assay Name"))
```
